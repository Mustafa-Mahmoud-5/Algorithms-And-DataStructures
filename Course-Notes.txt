________________________________BigO-Notation________________________________
1-what is the big O notation ?
    -it is a way of comparing between different solutions and defining the best alogirthm solution in terms of the performance and complexity(so it tells us which alogirthm is better than the other)

2-How does Big O compares between different Algoritms ?
    it gives some mathematical values for great,good,weak algorithms

3- when comparing between algorithms, we don`t depend on time as it varies between different pc features, but we count on the  numbers of the operations the computer does, the assignment operation, adding, substracting, comparing.. all of these are operations that the pc does

4-if we have a loop, the whole operations are recounter by the computer as the n(the variable we want to loop to) growth

5- the big O is just way to allow us to talk about the  relation between the input of algorithm and the runtime of the algorithm(how the algorithm runtime grows as the input grows)

6- we have different big O  relations between the input and the runtime
    * f(n) = x .... f is the function or the algorithm n is the input, x is the run time (based on n)
    1- f(n) = 1 >>> constant ratio (as the n increases, the runtime ratio won`t increase)
    2- f(n) = n >>> linear ratio (as the n increases, the runtime increases with the same ratio)
    3- f(n) = n^2 >>> quadratic ratio   (the runtime will increase by square the input) 

7- when we discriping the Big o we write a shortcut of O(f(n)), so in the linear ratio for example. since that f(n) = n therfore, O(f(n)) = O(n) and so on

8- so we compare between different algorithms using O(f(n)) rule

9- we ignore the number of operations the pc goes throug when we write the o(f(n) rule) so if we hav an algorithm that have 5 operations and loop through them by the input we insert, the f(n) = 5n, we don`t care about 5n we just write it as n then it will be O(n)

9- the speed of algorithm`s run time then is decided by the rule of the O(f(n))

10- the speed of big O notations algoritms
    1-O(1)
    2-O(log n)
    3-O(n)
    4-O(nlog n)
    5-O(n^2)

11- so we know how the biO is decided, and in more deep, but we need to be able to identify the big O of an algorith with out going through all these above steps(only for neccessary tracing) so the first rule to follow is to
    1- igonore the number of operations the computer does in the algorithm
    2- ignore all the constants(5n = n, 5n+10 = n, n^2 + 5n +10 = n^n, 500 = 1)
    3- focus on the relation between the input and if it will increase the operations the pc does or not (this is the only fastest way to get the big o)
    4- make sure also by outputting the algorithm with different input values to see if the input really changes the amount of the operations the pc does

12- all of that we were talking about the input and its relation with the runtime complexity, let`s talk about the space complexity

13- when the input value increases, the input space itself is increases and of course if the big o is n or n^2 it will affect the algorithm space, but we will study the auxilliary space complexity which only concerns with the space complexity of the algorithm itself without including the input with it

14- numbers, boolean,null are always have the big O value of O(1) in the space complexity as they are constant in the space

15- strings,arrays,objects are always have the big O value of 0(n) in the space complexity where n is the string/array/onject length

16- so if we have array or obj or string that grows within its length, the space complexity will increase in the memory



_________________________________Objects & Objects js built-in methods________________________

17- Objects are used in storing random(unordered) data and they are very fast when we talk about the Big O notation as the big O of the followings are :
    1- selecting: O(1)
    2- inserting: O(1)
    3- removing: O(1)
    4- searching: O(n)

18- the big O of some built in methods
    1-Object.keys() : O(n)
    2-Object.entries() : O(n)
    3-Object.hasOwnProperty: O(1)
_________________________________Arrays & Arrays js built-in methods__________________________

19- Arrays are also fast and they used for storing ordered data and the Big O of the followings are :
    1- searching: O(n)
    2- selecting: 0(1)
    3- Adding & Removing: it depends, if we push or pop then it will be O(1), but i will be O(n) if we shift or unshift because when we miss with the array from the beginning, any change will change the indexs of the rest of the arr elements, so avoid it as possible

20- the big O of some built in methods are:
    1- push & pop : O(1)
    2- shift & unsifht: O(n)
    3- concat: O(n) >> as it takes the array we want to merge and merge it with the old one, so as the array we want to concat gets bigger, we will merge larger elements which means more insertion processes which means O(n)
    4- slice() (it reutns a copy of array(maybe till specified inex if wrote)) : O(n) because as the number of elements we want to put in the array increases, the insertion process increases (another answer: because what this really does is looping through the old array till the specified index, and put them in new array)
    5- splice() : O(n) because it used to delete or add items in the beginning or middle and that means reindexing the whole array
    6- sort(): O(n * log n) as we loop then we start changing somethings
    7- forEach/map/filter/reduce : O(n)


____________________________________Problem Solving Approaches__________________________________

21- when we start thinking about a problem we must follow some helpful steps(by time you `ll be expert) 
    1- understand the problem
    2- thinking about some examples
    3- break it down
    4- solve
    5- look back and refactor


22- (UDERSTANDING THE PROBLEM), to do so, you must ask ur self some questions
    1- can i rename the questions on my own ?
    2- what are the inputs ?
    3- what ae the outputs ?
    4- does the outputs determined by the inputs ?
    5- what labels should i give to the data in the problem

23- (THINKING ABOUT SOME EXAMPLES), you should ask your self what if the user inserted some invalid inputs, or didn`t pass any thing, your problem can be solved to make different things and that`s we talk about, you should start with the simple example and after solving it, you then start thinking out of the box about handling different inputs and different outputs

24- (BREAK IT DOWN), its very useful before starting writting code to make comments inside the function body and write a blueprint of comments of the steps u r going to take


_____________________________________________Stacks__________________________________________________


stacks are data structures (a collection of data) that follow the rule of LIFO >>> Last In First Out and that means that the last item to be inserted in the collection will be the first thing to be removed from it and that is actually has alot of use cases in the real life like a cylender of balls, where the last ball we added `ll be the first ball to be removed when we decide to remove the balls. it also has a alot of use cases in the programming life like the undo/redo techneque where when we make changes it got added to the stack and when we undo changes we remove the last change we made, we also have another use case which is the routing process (the history object in react for example) when we visit a new page we push it to the container but when we go back, we remove the last page we added


